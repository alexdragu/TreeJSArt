<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - cameras</title>
		<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			b {
				color: lightgreen;
			}
		</style>
	</head>
	<body style="background-color:#477979FF">
<!--		
		<canvas class="webgl" id="canvasuwb"></canvas>
		<canvas class="webgl" id="canvasmain"></canvas>
-->

<!--
		<div class="webgl" id="divuwb" style="background-color: aqua; position: absolute; left:5%; top: 0;">

		</div>
		<div class="webgl" id="divaudio" style="background-color: aqua; position: absolute; right:5%; bottom: 0;">
		</div>
	-->

<style>
  .grid-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    width: 100vw;
    height: 100vh;	
    position: absolute;
  }
  .grid-item {
    border: 10px solid #333;
    box-sizing: border-box;
	display: flex;
    width: 100%;
    height: 100%;
	justify-content: center;
	align-items: center;
  }
  .grid-item-wrap {
    border: 10px solid #333;
    box-sizing: border-box;
	display: flex;
    width: 100%;
    height: 100%;
	justify-content: top;
	align-items: top;
	position: relative;
  }
 .title-label {
	color: lightgray;
	font-size: 20px;
	font-weight: bold;	
	margin: 0;
	
  }

  .grid-item-wrap:hover {
	background-color: lightgray;
  }
  .grid-item:hover {
	background-color: lightgray;
  }
</style>
<div class="grid-container" >
  <div class="grid-item-wrap" id="divaudio_wrap" style="background-color: transparent; "> 
	<table style="border: 2px; width: 100%; border-color: FF000000; background-color: #AAAAAA00; z-index: 100;">
		<tr style="height: 0%; background-color: #477979FF; margin-top: 0px; " >
			<td style="width: 100px;   padding: 10px; " colspan="2" >
				<p class="title-label">Audio Sensing</p>
			</td>

		</tr>
		<tr style="height: auto; background-color: #2222FF22; margin-top: 0px; vertical-align: top;">
			<td style="width: 100px; background-color: #AAAA11A0;">
				<p class="title-label">NewLine</p> Zonezone 2
			</td>
			<td style="width: 100px;">
				<p class="title-label">NewLine</p> Zonezone
			</td>
		</tr>
		
	</table>
  </div>
  <div class="grid-item-wrap" id="div2_wrap" style="background-color: lightgreen;">	
  </div>

  <div class="grid-item-wrap" id="div3_wrap" style="background-color: lightblue;">	
	<table style="border: 2px; width: 100%; border-color: FF000000; background-color: #AAAAAA11; z-index: 100;">
		<tr style="height: 0%; background-color: #444455FF; margin-top: 0px; " >
			<td style="width: 100px;   padding: 10px; " colspan="2" >
				<p class="title-label">Video Sensing</p>
			</td>

		</tr>
		<tr style="height: auto; background-color: #2222FF22; margin-top: 0px; vertical-align: top;">
			<td style="width: 100px; background-color: #AAAA11A0;">
				<p class="title-label">NewLine</p> Zonezone 2
			</td>
			<td style="width: 100px;">
				<p class="title-label">NewLine</p> Zonezone
			</td>
		</tr>
		
	</table>
  </div>
  
  <div class="grid-item-wrap" id="divuwb_wrap" style="background-color: transparent;">
	<table style=" border: 2px; width: 100%; border-color: FF000000; background-color: #AAAAAA11; z-index: 100;">
		<tr style="height: 0%; background-color: #477979FF; margin-top: 0px; " >
			<td style="width: 100px;   padding: 10px; " colspan="2" >
				<p class="title-label">CIR Data Sensing</p>
			</td>

		</tr>
		<tr style="height: auto; background-color: #2222FF22; margin-top: 0px; vertical-align: top;">
			<td style="width: 100px; background-color: #AAAA1100;">
				<p class="title-label">NewLine</p> Zonezone 2
			</td>
			<td style="width: 100px;">
				<p class="title-label">NewLine</p> Zonezone
			</td>
		</tr>
		
	</table>
  </div>
</div>

<div class="grid-container">
  <div class="grid-item" id="divaudio" style="background-color: transparent;">	
		  <img src="./textures/20240310_134042.jpg" alt="Descriptive text"  
		style="display:block; position:absolute; width: 400px; height: 400px; object-fit: fill; z-index: -1;">
  </div>
  <div class="grid-item" id="div2" style="background-color: transparent;"></div>
  <div class="grid-item" id="div3" style="background-color: aqua;"></div>
  <div class="grid-item" id="divuwb" style="background-color: transparent;">
		  <img src="./textures/scale.png" alt="Descriptive text"  
		style="display:block; position:absolute; width: 600px; height: 400px; object-fit: fill; z-index: -1;">
  </div>
</div>

		

		<div id="info" style="display:none"><a href="https://www.nxp.com" target="_blank" rel="noopener">NXP - </a>SI UWB GUI - Version v0.01<br/>
		<b>O</b> orthographic <b>P</b> perspective <b>H</b> <b>hide title </b>
		</div>
		<!-- https://github.com/mapbox/delaunator -->
		<script src="https://unpkg.com/delaunator@3.0.2/delaunator.js"></script>
		<script src="https://josephg.github.io/noisejs/perlin.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>


		<script type="x-shader/x-vertex" id="vertexshader_canvas">
			varying vec2 vUv;
			varying vec3 vColor;
			varying vec3 vNormal;

			void main() {
				vColor = color;
				vNormal = normal; 
				//vColor = vec3(1.0,1.0,0.0);
				vUv = uv;
								
				gl_Position =   projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader_canvas">

			uniform sampler2D pointTexture;
			varying vec3 vNormal;
			varying vec3 vColor;
			varying vec2 vUv;

			void main() {

    			vec3 lightDir = normalize(vec3(-0.9, 0.3, -0.7));
    			float diff = max(dot(normalize(vNormal), lightDir), 0.5);
    			gl_FragColor = vec4(vColor * diff, 1.0); // smooth color and lighting

				// good version without normals
				//gl_FragColor = vec4( vColor*1.0, 1.0) ;//+ vec4(vRightFriend0*0.5, 0.1); ;
				
				//gl_FragColor = vec4( vColor, 1.0)				
				//gl_FragColor = gl_FragColor * texture2D( pointTexture, vUv );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader_canvas_axis">

			uniform sampler2D pointTexture;
			varying vec3 vNormal;
			varying vec3 vColor;
			varying vec2 vUv;

			void main() {

    			//vec3 lightDir = normalize(vec3(-0.9, 0.3, -0.7));
    			//float diff = max(dot(normalize(vNormal), lightDir), 0.5);
    			//gl_FragColor = vec4(vColor * diff, 1.0); // smooth color and lighting

				// good version without normals
				//gl_FragColor = vec4( vColor*1.0, 1.0) ;//+ vec4(vRightFriend0*0.5, 0.1); ;
				gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0) ;//+ vec4(vRightFriend0*0.5, 0.1); ;
				
				//gl_FragColor = vec4( vColor, 1.0)				
				gl_FragColor = gl_FragColor * texture2D( pointTexture, vUv );

			}

		</script>



		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",					
					"three/addons/": "./jsm/",
					"three/lexblue/": "./lexblue/"
				}
			}
		</script>



<script src="https://unpkg.com/mqtt/dist/mqtt.js"></script>
<script type="module">



</script>


		<script type="module">

			import * as THREE from 'three';
			//import * as mqtt from 'mqtt';
			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
			import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
			import { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';
			import { LbMap } from 'three/lexblue/LbMap.js';
			import { AttributeGenerator } from 'three/lexblue/AttributeGenerator.js';

			import { HeightMesh, generateRandomHeights } from 'three/lexblue/Spectrum.js';



function getObjectsCount() {
	const url = `https://${window.location.hostname}:30001/get_count`;

	return fetch(url)
		.then(response => response.json())
		.then(data => {
			// Handle the response data here
			console.log("Count thing :" +data + " " + data.countx) ;
			return data.countx;
		})
		.catch(error => {
			// Handle any errors that occurred during the request
			console.error(error);
		});
}

function getObjectsCountFlat() {
	const url = `https://${window.location.hostname}:30001/get_flat_count`;

	return fetch(url)
		.then(response => response.json())
		.then(data => {
			// Handle the response data here
			console.log("Count thing :" +data + " " + data.countx) ;
			return data.countx;
		})
		.catch(error => {
			// Handle any errors that occurred during the request
			console.error(error);
		});
}

function getObjectString(entry) {
    const url = `https://${window.location.hostname}:30001/get_entry?obj_entry=${entry}`;

    return fetch(url)
        .then(response => response.text())  // Get the response as text
        .then(text => {
            //console.log('Raw response:', text);  // Log the raw response

            if (text) {  // If the response is not empty
                const data = JSON.parse(text);  // Parse the text as JSON
				return data;
            } else {
                console.log('Empty response');
            }
        })
        .catch(error => {
            console.error(error);
        });
}


function getFlatObjectString(entry) {
    const url = `https://${window.location.hostname}:30001/get_flat_entry?obj_entry=${entry}`;

    return fetch(url)
        .then(response => response.text())  // Get the response as text
        .then(text => {
            //console.log('Raw response:', text);  // Log the raw response

            if (text) {  // If the response is not empty
                const data = JSON.parse(text);  // Parse the text as JSON
				return data;
            } else {
                console.log('Empty response');
            }
        })
        .catch(error => {
            console.error(error);
        });
}


function getUWBString() {
    const url = `https://${window.location.hostname}:30001/get_mqtt_uwb`;

    return fetch(url)
        .then(response => response.text())  // Get the response as text
        .then(text => {
            //console.log('Raw response:', text);  // Log the raw response

            if (text) {  // If the response is not empty
                const data = JSON.parse(text);  // Parse the text as JSON
				return data;
            } else {
                console.log('Empty response');
            }
        })
        .catch(error => {
            console.error(error);
        });
}

const nx = 400, ny = 32;
const heights = generateRandomHeights(nx, ny, 0, 10);
//const xstep = 1, ystep = 10, h_factor = 0.01;
//const xstep = 0.5, ystep = 4, h_factor = 0.01;
const scalrate = 0.85;
const xstep_uwb = 0.25*scalrate, ystep_uwb = 2*scalrate, h_factor_uwb = 0.005*scalrate;

const xstep_audio = 0.3, ystep_audio = 2, h_factor_audio = 0.0;


			var divuwb, divaudio;

			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			let scrrapmap = 1;
			let container, stats, containerTitle;
			let camera, scene_uwb, scene_audio, renderer_uwb, renderer_audio, mesh, mesh3, meshstop, controls, controls1;
			let cameraRig, activeCameraUWB, activeCameraAudio, activeHelper;
			let cameraPerspective, cameraOrtho;
			let cameraPerspectiveHelper, cameraOrthoHelper;

			let effectController;
			let frustumSize = 200;

			// required for GUI
			let tess = - 1;	// force initialization

			// helpers
			let vnh;
			let vnh_particles;
			let vth;

			let gui;

			// global variyng params
			let show_camhelper = false;
			let go_auto = true;
			let camera_update = false;
			let hide_sphere = false;
			let clear_color = true;
			let clear_depth = true;
			let move_map = false;
			let lbMap;
			let autofit = false;

			let hide_squares = true;
			let hide_delaunay = true;
			let rotate_squares = true;
			let render_delaunay_wireframe = true;		
			
			let default_friends = 25;
			let default_proximity = 25;
			const uwbheightMesh = new HeightMesh();
			const audioheightMesh = new HeightMesh();
			
			let R = 100;

			// html elements
			let hdiv; // title
			let statspanel;

			// Randomizer
			const attributes = [
				{ name: 'winxcnt', range: [1, 7], variation: 0.03 , continuous: false},
				{ name: 'winycnt', range: [1, 7], variation: 0.03 , continuous: false},
				{ name: 'fact', range: [0.5, 1.0], variation: 0.01 , continuous: false},
				{ name: 'defIndexfi', range: [Math.PI/R, 2*Math.PI], variation: Math.PI/(2*R) , continuous: true},
				{ name: 'defIndextheta', range: [Math.PI/R, 2*Math.PI], variation: Math.PI/(2*R) , continuous: true}
			];

			let generator;			
			let lastRenderTime;
			let mapRawData;
			let objCount = 0;
			let objCountFlat = 0;

			let countries = [];
			var hrap = 1.0;

			let paddingPercentHorizontal = 0.2;
			let paddingPercentVertical = 0.2;

			let uwbsetindex = 0;
//
//          the uwb stream
//
			const RT_WIDTH = 600;
			const RT_HEIGHT = 400;

///
/// Here is where we set the defaults cartridge
///
			show_camhelper = false;
			go_auto = true;
			camera_update = false;
			hide_sphere = true;
			clear_color = true;
			clear_depth = true;
			move_map = true;
			autofit = false;
			hide_squares = true;
			hide_delaunay = true;
			rotate_squares = true;
			render_delaunay_wireframe = true;
			default_friends = 19;
			default_proximity = 23;
			frustumSize = 450;

//MQTT first
		const MAIN_TOPIC = "sca_ces_demo/ranger5/radar_child_presence_detection_and_seat_belt_reminder/application_data";
		const CIR_DATA = "cir_data";
		const TOPIC_DELIMITER = "/";
		const FULL_TOPIC = MAIN_TOPIC + TOPIC_DELIMITER + CIR_DATA;

		const client_ws_mqtt = mqtt.connect('wss://public.mqttserver.eu:8081'  ,
		{
			rejectUnauthorized: false // disables certificate validation
		});

		client_ws_mqtt.on('connect', () => {
		console.log('Connected')

		client_ws_mqtt.subscribe(FULL_TOPIC, (err) => {
				if (err) {
					console.error('Subscribe error:', err);
				} else {
					console.log('Subscribed to topic:', FULL_TOPIC);
				}
			});
		});

        client_ws_mqtt.on('message', (receivedTopic, message) => {
			if (receivedTopic === FULL_TOPIC) {
                //console.log(`Received message on topic ${receivedTopic}:`, message.toString());
				//console.log(`Received message on topic ${receivedTopic}:`, message);
				uwbheightMesh.updateUWB(message.toString());				
            }
        });

		// WS Version
		// WebSocket connection
		const socket = new WebSocket('wss://localhost:30001');
		socket.binaryType = 'arraybuffer';

		socket.onmessage = (event) => {		
			//console.log('WS Received from server:', event.data);
			const flat = new Uint16Array(event.data);
			//console.log('Flat array:', flat);
			uwbheightMesh.updateUWBArray(flat);			
			audioheightMesh.updateUWBArray(flat);
		};




			init();
			setPostDefaults();	
			updateEffectsController();
			animate();			
			onWindowResize();

			function setPostDefaults(){
				
				// hide HUD				
				hdiv.style.display = "none";				
				statspanel.style.display = "none";	
				gui.show(0);
				statspanel.style.display = "none";	
				/*
				hdiv.style.display = "block";				
				statspanel.style.display = "block";	
				gui.show(1);
				statspanel.style.display = "block";
				*/
			}


			// the sphere
			function init() {
				lastRenderTime = performance.now();

				hdiv = document.getElementById("info");
				
				container = document.createElement( 'div' );
				container.setAttribute("id","maindiv");				

				containerTitle = document.createElement( 'div' );
				containerTitle.setAttribute("id","mainTitle");
				containerTitle.innerHTML = "Work Title";

				containerTitle.style.maxWidth = "fit-content";
				containerTitle.style.margin = "auto";

				document.body.appendChild( container );
				//document.body.appendChild( containerTitle );

				scene_uwb = new THREE.Scene();
				scene_audio = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );
				camera.position.z = 2500;

				cameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 10000 );

				cameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );
				scene_uwb.add( cameraPerspectiveHelper );



				//
				//cameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );

				cameraOrtho = new THREE.OrthographicCamera
				( hrap * frustumSize * aspect / - 2, 
				hrap *  frustumSize * aspect / 2, 
				frustumSize / 2, 
				frustumSize / - 2, 
				150, 10000 );

				cameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );
				//scene.add( cameraOrthoHelper );

				//
				activeCameraUWB = cameraPerspective;
				activeCameraAudio = cameraPerspective;

				activeHelper = cameraOrthoHelper;

				// counteract different front orientation of cameras vs rig
				cameraOrtho.rotation.y = Math.PI;
				cameraPerspective.rotation.y = Math.PI;

				cameraRig = new THREE.Group();

				cameraRig.add( cameraPerspective );
				cameraRig.add( cameraOrtho );

				scene_uwb.add( cameraRig );
				scene_audio.add( cameraRig );

				//
				mesh = new THREE.Mesh(
					new THREE.SphereGeometry( R, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x444444, wireframe: true } )
				);
				vnh = new VertexNormalsHelper( mesh, 5 );
				// adding helpers on the mesh
				mesh.add(vnh);

				if (!hide_sphere)
					cameraRig.add( mesh );


				mesh.position.z = -150;
				mesh.position.y = 150;				
			
				mesh3 = new THREE.Mesh(
					new THREE.SphereGeometry( 5, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )
				);

				meshstop = new THREE.Mesh(
					new THREE.SphereGeometry( R, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )
				);

				meshstop.position.z = -150;
				meshstop.position.y = 150;				
				mesh3.position.z = 150;

				//cameraRig.add( mesh3 );
				if (!hide_sphere)
					cameraRig.add( meshstop );


				uwbheightMesh.init(heights, xstep_uwb, ystep_uwb, h_factor_uwb, nx, ny);
				uwbheightMesh.init_axes(-0.5);
				
				uwbheightMesh.renderGroup.rotation.y = 0;
				uwbheightMesh.renderGroup.rotation.x = -Math.PI/2 - Math.PI/5;
				uwbheightMesh.renderGroup.rotation.z = -Math.PI/10;
				uwbheightMesh.renderGroup.position.x = 0;
				uwbheightMesh.renderGroup.position.y = 0;
				uwbheightMesh.renderGroup.position.z = 300;
				
				uwbheightMesh.render(scene_uwb);


				audioheightMesh.init(heights, xstep_audio, ystep_audio, h_factor_audio,nx, ny);

				audioheightMesh.mesh.rotation.y = 0;
				audioheightMesh.mesh.rotation.x = 0;
				audioheightMesh.mesh.rotation.z = 0;

				audioheightMesh.mesh.position.x = 0;
				audioheightMesh.mesh.position.y = 0;
				audioheightMesh.mesh.position.z = 300;
				
				audioheightMesh.render(scene_audio);			

/*
//Prepare the uwb renderer
*/				
				divuwb = document.getElementById('divuwb');				
				renderer_uwb = new THREE.WebGLRenderer( {preserveDrawingBuffer: true , antialias: true , alpha:true} );				
				renderer_uwb.setPixelRatio( window.devicePixelRatio );
				renderer_uwb.setSize(RT_WIDTH, RT_HEIGHT);				
				renderer_uwb.autoClear = false;
				divuwb.appendChild( renderer_uwb.domElement );
				

/*
// Prepare the audio signal renderer
*/
				divaudio = document.getElementById('divaudio');				
				renderer_audio = new THREE.WebGLRenderer( {preserveDrawingBuffer: true , antialias: true , alpha:true} );				
				renderer_audio.setPixelRatio( window.devicePixelRatio );
				renderer_audio.setSize(RT_WIDTH, RT_HEIGHT);				
				renderer_audio.autoClear = false;
				divaudio.appendChild( renderer_audio.domElement );

				/*
				// RENDER BUFFER
				renderTarget = new THREE.WebGLRenderTarget(RT_WIDTH, RT_HEIGHT);
				canvas2D = document.getElementById('divuwb');
				//canvas2D = document.querySelector('canvasuwb');
				canvas2D.width = RT_WIDTH;
				canvas2D.height = RT_HEIGHT;
				*/

				//ctx = canvas2D.getContext('2d');
				//imageData = ctx.createImageData(RT_WIDTH, RT_HEIGHT);
				// Add canvas to your HTML
				//document.body.appendChild(canvas2D);

				stats = new Stats('mapCoords','activeSpots', 'speedSubj', 'spotsubj');

				container.appendChild( stats.dom );
				stats.dom.setAttribute("id","statspanel");
				statspanel = document.getElementById("statspanel");

				window.addEventListener( 'resize', onWindowResize );
				document.addEventListener( 'keydown', onKeyDown );

				window.addEventListener('dblclick', onDblclick);
				

				controls = new TrackballControls( camera,  renderer_uwb.domElement);  //
				//controls = new TrackballControls( camera, document.documentElement);  //
				controls1 = new TrackballControls( camera,  renderer_audio.domElement);  //

				gui = setupGui();

				// prepare the generator
				generator = new AttributeGenerator(attributes,lbMap);
				generator.generateRandomSet();

			}
			
			function mapscr (){
				lbMap.setScrSize(-0.5 * frustumSize * aspect * effectController.scrrapmap, 
				frustumSize*effectController.scrrapmap );
				scrrapmap = effectController.scrrapmap;
			}

			function remap(){

				frustumSize = effectController.frustumSize;

				cameraOrtho.left = hrap * frustumSize * aspect / -2;
				cameraOrtho.right = hrap * frustumSize * aspect / 2;
				cameraOrtho.top = frustumSize / 2;
				cameraOrtho.bottom = frustumSize / -2;
				cameraOrtho.updateProjectionMatrix();

				activeCamera = cameraOrtho;
				activeHelper = cameraOrthoHelper;

				//lbMap.ReGenerateMap(false);
			
			}

			function pullRemoteObject (objId, mode = 0){
				getObjectString(objId).then(mapRawData => {
					console.log("Country : " + mapRawData.name);
					console.log("Obj coords : " + mapRawData.coordinates);							
					const nameExists = countries.some(country => country.name === mapRawData.name);

					if (!nameExists) {
						countries.push({ name: mapRawData.name, data: mapRawData.coordinates, mapmode: 0 });

						lbMap.initMapData(mapRawData.coordinates, 0);
						lbMap.ReGenerateMap(true);

						//cameraRig.add( lbMap.particlesMap );
					}
				});
			}

			function pullRemoteObjectFlat (objId, tgmode = 0){
				getFlatObjectString(objId).then(mapRawData => {
					console.log("Obj name : " + mapRawData.name);
					console.log("Obj coords : " + mapRawData.coordinates);	
					const nameExists = countries.some(country => country.name === mapRawData.name);

					if ((!nameExists) || (tgmode==1)){

						lbMap.initMapData(mapRawData.coordinates, 1, tgmode);			
						
						// only regenerate map if neww contet added to full map
						if (tgmode == 0){
							countries.push({ name: mapRawData.name, data: mapRawData.coordinates , mapmode: 1});
							lbMap.ReGenerateMap(true);
						}else{
							console.log("Regenerate!!!!!");
						}

						//cameraRig.add( lbMap.particlesMap );
					}
				});
			}

			function pullUWB(){
				getUWBString().then(uwbset => {
					//console.log("UWB index : " + uwbset.index);
					//console.log("UWB data : " + uwbset.data);
					uwbsetindex = uwbset.index;
					uwbheightMesh.updateUWB(uwbset.data);
				});
			}


			function setupGui() {

				effectController = {
					frustumSize: frustumSize,
					newTess: 15,
					//autofit: lbMap.autofit,
					friends: default_friends,
					proximity: default_proximity,
					refriend: true,
					scrrapmap: scrrapmap,
					newShading: 'glossy',
					show_camhelper: show_camhelper,

					hide_sphere: hide_sphere,

					clear_color: clear_color,
					clear_depth: clear_depth,
					
					go_auto: go_auto,				
/*					
					winSizeW: lbMap.window_w,
					winSizeH: lbMap.window_h,
					fact: lbMap.fact,
					mag: lbMap.mag, 
					defIndexfi: lbMap.defIndexfi,
					defIndextheta: lbMap.defIndextheta,
*/					
					move_map: move_map,
				};

				const gui = new GUI();
				gui.domElement.setAttribute("id","bluecontrol");
				gui.add( effectController, 'frustumSize' ).name( 'Frustum' ).onChange( remap );
				gui.add( effectController, 'scrrapmap', 0, 2.0 ).name('Screen Rap').step( 0.1 ).listen().onChange( mapscr );

				gui.add( effectController, 'move_map' ).name( 'Move P S' ).onChange( render );
				gui.add( effectController, 'friends' ).name( 'friends' ).onChange( render );
				gui.add( effectController, 'proximity' ).name( 'proximity' ).onChange( render );
				gui.add( effectController, 'refriend' ).name( 'refriend' ).onChange( render );
				//gui.add( effectController, 'newShading', [ 'wireframe', 'flat', 'smooth', 'glossy', 'textured', 'reflective' ] ).name( 'Shading' ).onChange( render );

				gui.add( effectController, 'show_camhelper' ).name( 'Cam Helper' ).onChange( render );
				gui.add( effectController, 'clear_color' ).name( 'Clear Color' ).onChange( render );
				gui.add( effectController, 'clear_depth' ).name( 'Clear Depth' ).onChange( render );

				gui.add( effectController, 'go_auto' ).name( 'Auto Move' ).onChange( render );
				 
/*
				gui.add( effectController, 'winSizeW', 1, 2*R ).name('Window Size X').step( 1 ).listen().onChange( render );
				gui.add( effectController, 'winSizeH', 1, 2*R ).name('Window Size y').step( 1 ).listen().onChange( render );
				gui.add( effectController, 'fact', 0.5, 2 ).name('Window Factor (gap)').step( 0.01 ).listen().onChange( render );
				gui.add( effectController, 'mag', 1, 10 ).name('Generic Mag').step( 0.5 ).listen().onChange( render );				

				gui.add( effectController, 'defIndexfi', Math.PI/R, 2*Math.PI ).name('Phi Offset').step( Math.PI/R ).listen().onChange( render );
				gui.add( effectController, 'defIndextheta', Math.PI/R, 2*Math.PI ).name('Theta Offset').step( Math.PI/R ).listen().onChange( render );

				gui.add( effectController, 'show_friend_idx', 1, 100000 ).name('FriendIndex').step( 1 ).listen().onChange( render );
*/
				return gui;
			}


			function onDblclick(){			
                const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement
				console.log("Full screen element: " + fullscreenElement);
				//const canvas = document.getElementById('divuwb').querySelector('canvas');

				document.documentElement.requestFullscreen();

                if (!fullscreenElement) {
                    if (canvas.requestFullscreen) {
                        canvas.requestFullscreen()
                    }
                    else if (canvas.webkitRequestFullscreen) {
                        canvas.webkitRequestFullscreen()
                    }
                }
                else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen()
                    }
                    else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen()
                    }
                }            
			}

			function onKeyDown( event ) {
				let cntrl = document.getElementById("bluecontrol");
				switch ( event.keyCode ) {

					case 79: /*O*/						
						//lbMap.ReGenerateMap(false);
						activeCameraUWB = cameraOrtho;
						activeCameraAudio = cameraOrtho;

						activeHelper = cameraOrthoHelper;
						break;
					case 80: /*P*/
						//lbMap.ReGenerateMap(false);
						activeCameraUWB = cameraPerspective;
						activeCameraAudio = cameraPerspective;
						
						activeHelper = cameraPerspectiveHelper;

						break;
					case 74: /*J*/
						lbMap.defIndexv--;
						//lbMap.updateMap();
						lbMap.ReGenerateMap(true);
						//lbMap.updateWindows();
						break;
					case 85: /*U*/						
						lbMap.defIndexv++;
						//lbMap.updateMap();
						lbMap.ReGenerateMap(true);
						//lbMap.updateWindows();
						break;												
					case 73: /*I*/						
						lbMap.defIndexh++;
						//lbMap.updateMap();
						lbMap.ReGenerateMap(true);
						//lbMap.updateWindows();
						break;						
					case 75: /*K*/
						lbMap.defIndexh--;
						//lbMap.updateMap();
						lbMap.ReGenerateMap(true);
						//lbMap.updateWindows();
						break;
					case 72: /*H*/						
						if (hdiv.style.display === "none") {
							hdiv.style.display = "block";
							gui.show(1);
							statspanel.style.display = "block";
							//stats.showPanel(0);
						} else {
							hdiv.style.display = "none";
							gui.show(0);
							//stats.showPanel(1);
							statspanel.style.display = "none";							
						}
						break;
					case 70: /*F*/
						cntrl = document.getElementById("bluecontrol");
						if (cntrl.style.display === "none") {
							cntrl.style.display = "block";
						} else {
							cntrl.style.display = "none";
						}
						break;
					case 71: /*G*/
						generator.generateRandomSet();
						generator.setValuesToTarget();
						updateEffectsController();
						lbMap.factory();
						console.log("Randomized " + lbMap.winxcnt + " " + lbMap.winycnt + " " + lbMap.fact);
						lbMap.ReGenerateMap(false);
						break;

					case 68: /*D*/
						generator.step(100.0/60.0);
						updateEffectsController();
						lbMap.factory();
						console.log("Randomized " + lbMap.winxcnt + " " + lbMap.winycnt + " " + lbMap.fact + " " + lbMap.defIndexfi + " " + lbMap.defIndextheta);
						lbMap.ReGenerateMap(false);
						break;		
						
					case 83: /*S*/
						
						const objId = Math.floor(Math.random() * objCount);
						console.log("Random Object " + objId + " of : " + objCount);
						pullRemoteObject (objId);
						
						break;							
					case 65: /*A*/

						for (let objId = 1; objId < objCount; objId++) {
							console.log("Pulling remote object " + objId + " of: " + (objCount - 1));
							pullRemoteObject(objId);
						}
						break;
					case 90: /*Z*/
						lbMap.updateMapCoords();	
						lbMap.ReGenerateMap(false);
						break;
					case 88: /*X*/
						const objIdFlat = Math.floor(Math.random() * objCountFlat);
						console.log("Random Object " + objIdFlat + " of : " + objCountFlat);
						pullRemoteObjectFlat (objIdFlat);
						break;
					case 67: /*C*/
						let objIdFlatT = Math.floor(Math.random() * objCountFlat);
						console.log("Random Flat Object " + objIdFlatT + " of : " + objCountFlat);
						//lbMap.delaunyInitialized = false;
						pullRemoteObjectFlat(objIdFlatT, 1);
						break;
						// set spiral as target
					case 86: /*V*/
						pullUWB();
						lbMap.updateMapCoords(1);
						break;
				}
				console.log(event.keyCode);

			}

			//

			function onWindowResize() {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;
				//aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				aspect = RT_WIDTH / RT_HEIGHT;
				
				//aspect = SCREEN_WIDTH * (1.0- paddingPercentHorizontal) / SCREEN_HEIGHT * (1.0-paddingPercentVertical);				

				///renderer.setSize( SCREEN_WIDTH * (1.0- paddingPercentHorizontal), SCREEN_HEIGHT * (1.0-paddingPercentVertical) );

								    // Update renderer
				renderer_uwb.setSize(RT_WIDTH, RT_HEIGHT);
				//renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

				//camera.aspect = 0.5 * aspect;
				camera.aspect = aspect;
				camera.updateProjectionMatrix();

				//cameraPerspective.aspect = 0.5 * aspect;
				cameraPerspective.aspect = 0.5 *aspect;
				cameraPerspective.updateProjectionMatrix();
/*
				cameraOrtho.left = hrap * frustumSize * aspect / -2;
				cameraOrtho.right = hrap * frustumSize * aspect / 2;
				cameraOrtho.top = frustumSize / 2;
				cameraOrtho.bottom = frustumSize / -2;
				cameraOrtho.updateProjectionMatrix();
*/
				//lbMap.setScrSize(-0.5 * frustumSize * aspect / - 2, frustumSize / 2 );
				//lbMap.updateMap();
				//lbMap.updateWindows();
				
				console.log("______WINDOW RESIZE______________" + SCREEN_WIDTH + " SH: " + SCREEN_HEIGHT);

				//lbMap.ReGenerateMap(false);

			}

			//


			function animate() {
				const currentRenderTime = performance.now();
				const timeBetweenRenders = currentRenderTime - lastRenderTime;
				requestAnimationFrame( animate );				
				//heightMesh.update(timeBetweenRenders/60);
				
				if (go_auto) {
					// this is the version with service
					//pullUWB();
				}

				render();
				stats.update(uwbsetindex, 1,"empty","placeholder"
				);

				//console.log("RRR" + lbMap.mapCoords.length + " " + lbMap.activeMapCoords.length)
			}

			function updateEffectsController(){
				//effectController.hstep = lbMap.Hstep;
				//effectController.vstep = lbMap.Vstep;
				//effectController.winSizeW = lbMap.window_w;
				//effectController.winSizeH = lbMap.window_h;
				//effectController.fact = lbMap.fact;
				//effectController.mag = lbMap.mag;
				//effectController.winxcnt = lbMap.winxcnt;
				//effectController.winycnt = lbMap.winycnt;

				//effectController.defIndexfi = lbMap.defIndexfi;
				//effectController.defIndextheta = lbMap.defIndextheta;				
			}

			var angle = 0;
			function render() {
				//console.log	("Render called");
				const currentRenderTime = performance.now();
				const timeBetweenRenders = currentRenderTime - lastRenderTime;
//				console.log(`Time between renders: ${timeBetweenRenders} ms`);
				lastRenderTime = currentRenderTime;

				if (effectController.go_auto != go_auto){
					go_auto = effectController.go_auto;
				}

				if (effectController.hide_sphere != hide_sphere){
					hide_sphere = effectController.hide_sphere;
					if (hide_sphere){
						cameraRig.remove( mesh );
						cameraRig.remove( meshstop );
					} else {
						cameraRig.add( mesh );
						cameraRig.add( meshstop );
					}
				}

		var quaternion = new THREE.Quaternion();
		angle += 0.001;

		var center = new THREE.Vector3(0, 0, 0);
		mesh.geometry.computeBoundingBox();
		quaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);
		mesh.quaternion.copy(quaternion);

		if (go_auto){
			// The movement				
			//generator.step(timeBetweenRenders/60);				
			updateEffectsController();			
		}

				const r = 0;


				if (show_camhelper != effectController.show_camhelper){
					show_camhelper = effectController.show_camhelper;
				}

				
				if ( activeCameraUWB === cameraPerspective ) {

					cameraPerspective.fov = 35 + 30 * Math.sin( 0.5 * r );
					cameraPerspective.far = mesh.position.length()*2;
					cameraPerspective.updateProjectionMatrix();

					cameraPerspectiveHelper.update();

					cameraPerspectiveHelper.visible = false;					
					cameraOrthoHelper.visible = false;

				} else {

					cameraOrtho.far = mesh3.position.length()*5;
					cameraOrtho.updateProjectionMatrix();

					cameraOrthoHelper.update();
					cameraOrthoHelper.visible = true;

					cameraOrthoHelper.visible = false;
					cameraPerspectiveHelper.visible = false;

				}

				
				cameraRig.lookAt( mesh3.position );
				
				
				renderer_uwb.clear(effectController.clear_color, effectController.clear_depth, true);
				renderer_audio.clear(effectController.clear_color, effectController.clear_depth, true);

				controls.update();
				controls1.update();

				activeHelper.visible = true;

				if (show_camhelper){
					activeHelper.visible = true;
					renderer_uwb.setViewport( 0, 0,RT_WIDTH, RT_HEIGHT );
					renderer_uwb.render( scene_uwb, activeCameraUWB );

					activeHelper.visible = true;
					renderer_uwb.setViewport( RT_WIDTH / 2, 0, RT_WIDTH / 2, RT_HEIGHT );
					renderer_uwb.render( scene_uwb, camera );

					activeHelper.visible = true;
					renderer_audio.setViewport( 0, 0,RT_WIDTH, RT_HEIGHT );
					renderer_audio.render( scene_audio, activeCameraAudio );					

					activeHelper.visible = true;
					renderer_audio.setViewport( RT_WIDTH / 2, 0, RT_WIDTH / 2, RT_HEIGHT );
					renderer_audio.render( scene_audio, camera );

				}else{
					renderer_uwb.setViewport( 0, 0, RT_WIDTH, RT_HEIGHT );					
					renderer_uwb.render( scene_uwb, activeCameraUWB );
					

					renderer_audio.setViewport( 0, 0, RT_WIDTH, RT_HEIGHT );					
					renderer_audio.render( scene_audio, activeCameraAudio );
					activeHelper.visible = false;
				}
			}


		</script>

	</body>
</html>
